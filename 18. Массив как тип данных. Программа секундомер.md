# 18 Билет
## Теория 

**Массив как тип данных. Особенности использования массивов при разработке программ на си.**

**Массивы в C** - это коллекции элементов одного типа, расположенные в памяти последовательно. Они позволяют хранить несколько значений под одним именем переменной, что упрощает работу с большими объёмами данных.

Основные свойства массивов:
1. Индексированность: Каждый элемент массива доступен по уникальному номеру — индексу. Индексация начинается с нуля, поэтому первый элемент массива имеет индекс 0.
2. Непрерывность расположения: Все элементы массива располагаются подряд в памяти, что упрощает быстрый доступ к любому элементу по смещению от начального адреса.
3. Однородность: Все элементы массива принадлежат одному типу данных (целые числа, символы, структуры и т.д.).
4. Зафиксированный размер: Размер массива задаётся при объявлении и не изменяется в течение выполнения программы.

Важные моменты при работе с массивами:
1. Инициализация: Массив можно инициализировать при объявлении, перечислив значения в фигурных скобках. Если указаны не все элементы, оставшиеся заполняются нулями.
2. Не превышайте индексы: Попытка доступа к элементу массива с индексом, превышающим размер массива, приведёт к неопределённым результатам или повреждению памяти.
3. Память: Массивы размещаются в стеке (локально) или в куче (динамически). Локальные массивы уничтожаются при выходе из блока, динамические — освобождаются оператором free().
## Практика 
Разработка программы-секундомера. в одном потоке идет отсчет времени, а в другом осуществляется управление секундомером (отдельно для Windows и Linux)

Шаг 1. В Windows создадим такую программу в файле main.c

``` C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

struct SecTime {
	int hours;
	int minutes;
	int seconds;
};

struct SecTime time;
HANDLE hF[2];

DWORD WINAPI StartSecundomer() {
	while (1) {
		time.seconds++;
		if (time.seconds == 60) {
			time.minutes++;
			time.seconds = 0;
			if (time.minutes == 60) {
				time.hours++;
				time.minutes = 0;
			}
		}
		Sleep(1000);
	}
}

DWORD WINAPI ControlSecundomer() {
	while (1) {
		printf("0. Запустить секундомер\n");
		printf("1. Показать время секундомера\n");
		printf("2. Поставить на паузу\n");
		printf("3. Возобновить паузу\n");
		printf("4. Сбросить секундомер\n");
		int choice = 0;
		scanf_s("%d", &choice);
		switch (choice) {
		case 0: ResumeThread(hF[0]); break;
		case 1: printf("%02d:%02d:%02d\n", time.hours, time.minutes, time.seconds); break;
		case 2: SuspendThread(hF[0]); break;
		case 3: ResumeThread(hF[0]); break;
		case 4: 
			SuspendThread(hF[0]);
			time.hours = 0;
			time.minutes = 0;
			time.seconds = 0;
			break;
		default: break;
		}
	}
}

int main() {
	system("chcp 1251");
	hF[0] = CreateThread(0, 0, StartSecundomer, 0, 0, 0);
	hF[1] = CreateThread(0, 0, ControlSecundomer, 0, 0, 0);
	WaitForMultipleObjects(2, hF, TRUE, INFINITE);
}
```

Шаг 2. В Linux создадим такую программу в файле main.c 

``` C
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

struct SecTime
{
	int hours;
	int minutes;
	int seconds;
};

struct SecTime currentTime;
int flagRun = 0;
pthread_t hf[2];

void* StartSecundomer(void* arg)
{
	while (1)
	{
		if (flagRun)
		{
			currentTime.seconds++;
			if (currentTime.seconds == 60)
			{
				currentTime.seconds = 0;
				currentTime.minutes++;
				if (currentTime.minutes == 60)
				{
					currentTime.minutes = 0;
					currentTime.hours++;
				}
			}
			sleep(1);
		}
	}
}

void* ControlSecundomer(void* arg)
{
	while (1)
	{
		printf("0. Запустить секундомер\n");
		printf("1. Показать время секундомера\n");
		printf("2. Поставить на паузу\n");
		printf("3. Возобновить паузу\n");
		printf("4. Сбросить секундомер\n");
		printf("5. Завершить программу\n");
		int choise = 0;
		scanf("%d", &choise);
		switch (choise)
		{
		case 0: flagRun = 1; break;
		case 1: printf("Секундомер: %02d:%02d:%02d\n", currentTime.hours, currentTime.minutes, currentTime.seconds); break;
		case 2: flagRun = 0; break;
		case 3: flagRun = 1; break;
		case 4: flagRun = 0; currentTime.hours = 0; currentTime.minutes = 0; currentTime.seconds = 0; break;
		case 5: exit(0); break; //завершение всех потоков
		default: break;
		}
	}
}

int main()
{
	pthread_create(&hf[0], 0, StartSecundomer, 0);
	pthread_create(&hf[1], 0, ControlSecundomer, 0);
	pause();
}
```

