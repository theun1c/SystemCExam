# 29 Билет
## Теория

**Сигналы. Особенности создания и использования сигналов + виды сигналов**

Что такое сигнал?

Сигнал — это короткое системное уведомление от ОС процессу о важном событии. Это как если ОС постучалась в дверь программы: «Эй, пора завершаться» «Эй, пользователь нажал Ctrl+C» «Эй, ты полез в плохую память — прекращай!»

Живые примеры:

Пример 1. Выключение Windows, а файл не сохранён

Когда ты жмёшь _Завершение работы_, ОС посылает приложениям сигнал «готовься к завершению». Например, Word получает уведомление: → «Система завершается, сохраните данные!» И Word показывает окно: «Сохранить изменения? ✓ Да ✓ Нет ✓ Отмена завершения работы» Это и есть обработка сигнала перед завершением.

Пример 2. Linux: нажали Ctrl+C Ctrl+C → сигнал SIGINT.

Программа может не упасть, а, например: — аккуратно остановить расчёты, — сохранить промежуточный результат, — вывести сообщение: «Работа остановлена пользователем».

Виды сигналов:

- Управляющие:

1. SIGINT – Прерывание Ctrl+C
2. SIGTERM - Корректное завершение kill PID
3. SIGKILL - Мгновенное убийство kill -9 PID (не перехватывается!)
4. SIGHUP - Потеря связи / перезагрузка Терминал закрылся; перезапуск конфигурации демона

- Ошибки:
1. SIGSEGV Ошибка сегментации неправильный указатель
2. SIGFPE Ошибка арифметики деление на 0
3. SIGILL Неверная инструкция повреждённый код

- Для процессов:
1. SIGCHLD Дочерний процесс завершился родитель узнаёт, что можно читать статус
2. SIGSTOP Остановить процесс как пауза
3. SIGCONT Продолжить снять паузу

Как программа ловит сигнал:

Простой пример:

``` C
#include <signal.h>
#include <stdio.h>

void handler(int sig) {
	printf("Получен сигнал: %d\n", sig);
}
int main() {

	signal(SIGINT, handler); // перехват Ctrl+C

	while(1); // бесконечная работа

	}
}
```

Теперь Ctrl+C не убьёт программу — она просто выведет сообщение.

## Практика 

Использование анонимного канала для передачи строковых значений между процессами (отдельно для Windows и Linux)

Для винды:

проект 1
``` C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <Windows.h>
#define PATH "ProjectSecond.exe" //имя запускаемого дочернего процесса

HANDLE hRead, hWrite;//дескрипторы чтения и записи в анонимный канал
SECURITY_ATTRIBUTES sa = { sizeof(sa), 0, TRUE };//структура безопасности, в которой разрешено наследование дескрипторов

int main()
{
	system("chcp 1251>nul");
	CreatePipe(//создаем анонимный канал
		&hRead,//ссылка на дескриптор для чтения
		&hWrite,//ссылка на дескриптор для записи
		&sa, //указатель на структуру безопасности
		0);	//размер буфера канала
	LPSTR str = calloc(100, 1);//для аргументов командной строки
	sprintf(str, "%d %d", hWrite, hRead);//переводим дескриптор для записи в строку
	STARTUPINFO si = calloc(1, sizeof(STARTUPINFO));				// структура
	si->cb = sizeof(STARTUPINFO);
	PROCESS_INFORMATION pi = calloc(1, sizeof(PROCESS_INFORMATION));
	if (!CreateProcessA(PATH,//путь к файлу
		str,//агрументы командной строки
		0,//структура безопасности процесса
		0,//структура безопасности потока
		TRUE,//наследовать дескриптор нового процесса от старого?
		0,//флаги приоритета процессов CREATE_NEW_CONSOLE
		0,//среда окружения процесса ANSI или UNICODE
		0,//консольный путь к каталогу, из которого вызывается процесс
		&si,//указатель на структуру STARTUPINFO
		&pi))//указатель на структуру PROCESS_INFORMATION
	{
		printf("Не удалось создать процесс. Код ошибки: %d.\n", GetLastError());
	}
	WriteFile(hWrite, "ОПААААААА", 66, 0, 0);	//пишем в канал
	return 0;
}
```
проект 2

``` C
#include <stdio.h>
#include <Windows.h>
HANDLE hRead, hWrite;//дескрипторы чтения и записи в анонимный канал
int main(int argc, char* argv[])
{   
    system("chcp 1251>nul");
	hWrite = (HANDLE) atoi(argv[0]);
	hRead = (HANDLE) atoi(argv[1]);
	system("pause");
	CloseHandle(hWrite);//закрываем дескриптор для записи у потомка
	char buffer[100];
	ReadFile(hRead, buffer, 100, 0, 0);//читаем данные из канала
	printf("Ребенок прочитал: %s и завершил работу \n", buffer);
	return(0);
}
```

Для линукса

``` C
#include <stdio.h>
#include <unistd.h> //fork, close, read, write, pipe, _exit
#include <sys/wait.h> //wait
#include <string.h>//strlen
#include <malloc.h>

int main() {

	int pfd[2]; // Файловые дескрипторы канала
	char* text = "Hello";
	int size = strlen(text);
	ssize_t numRead;
	if (pipe(pfd) == -1) // Создаем канал
		_exit(1);//в случае ошибки завершаем работу программы
	switch (fork()) {
	case -1:
		_exit(1);
	case 0: //потомок только читает данные из канала
		if (close(pfd[1]) == -1) // Записывающий конец не используется
			_exit(1);
			do { // Считываем данные из канала до тех пор, пока он не опустеет
				char * buf = calloc(1, 1);//создаем буфер для чтения
				numRead = read(pfd[0], buf, 1);//операция блокируется до тех пор, пока в канал не поступят данные
				printf("Родитель написал: %s\n",buf);//выводим на экран то, что прочитали
				free(buf);//очищаем буфер
			}
			while (numRead != 0);
				if (close(pfd[0]) == -1)
					_exit(1);
				_exit(0);
	default: // Родитель записывает в канал
		if (close(pfd[0]) == -1) // Считывающий конец не используется
			_exit(1);
		if (write(pfd[1], text, size) != size)
			_exit(1);
		if (close(pfd[1]) == -1) // Потомок увидит символ завершения файла
			_exit(1);
		wait(0); // Ждем завершения потомка
		_exit(0);
	}
}
```