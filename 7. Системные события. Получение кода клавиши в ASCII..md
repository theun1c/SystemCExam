# 7 Билет
## Теория 

**Особенности разработки программ для работы с системными событиями использования мыши и клавиатуры.**

Суть:
Когда пользователь взаимодействует с компьютером (щёлкает мышью, двигает её, нажимает клавиши), операционная система отправляет специальное уведомление (событие) вашему приложению. Оно помещается в очередь сообщений, и ваше приложение должно своевременно отреагировать на каждое событие.

Пример:
Допустим, вы пишете программу, которая рисует кружочки на экране при каждом клике мыши. Когда пользователь щёлкает, ОС посылает сообщение WM_LBUTTONDOWN. Ваша программа обрабатывает это событие, получает координаты клика и рисует круг.

Важные моменты:
1.       Реакцию нужно давать немедленно: Ваше приложение должно быстро отвечать на события. Если затянуть обработку (например, начать долгую операцию прямо в обработчике события), возникнет задержка, и последующие события будут скапливаться в очереди.
2.       Есть риск потерять события: Если обработка одного события займёт слишком много времени, следующие события могут не дождаться обработки и пропасть.
3.       Учёт состояний мыши и клавиатуры: Важно учитывать дополнительные факторы, такие как текущие активные клавиши-модификаторы (Ctrl, Shift, Alt) и положение курсора мыши.
4.       Ограниченное время обработки: Длительная операция в обработчике может привести к замораживанию интерфейса. Лучше перенести тяжёлые задачи в отдельные потоки или поставить в очередь на дальнейшее выполнение.

## Практика
Получение кода клавиши в формате ASCII и использованием Windows HOOK. Название клавиши выводить в MessageBox

Шаг 1. Напишем следующий код в main.c файл. 
``` C
#include <windows.h>

LRESULT CALLBACK HookProc(int code, WPARAM wParam, LPARAM lParam)
{
	if (code >= 0 && wParam == WM_KEYDOWN)
	{
		PKBDLLHOOKSTRUCT pKeyboard = lParam;
		char ASCIIChar = pKeyboard->vkCode;
	
		wchar_t symbol[100];
		wsprintf(symbol, L"%lc", (wchar_t)ASCIIChar);
		MessageBoxW(0, symbol, L"Нажатая клавиша", 0);
	}
	return CallNextHookEx(0, code, wParam, lParam); //переходим к следующему перехватчику
}


int main()
{
	system("chcp 1251");
	//создание перехватчика
	HHOOK hHook = SetWindowsHookExW(WH_KEYBOARD_LL, HookProc, GetModuleHandle(0), 0);

	MSG msg;
	while (GetMessageW(&msg, 0, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessageW(&msg);
	}

	UnhookWindowsHookEx(hHook); //удаление перехватчика
	return 0;
}
```