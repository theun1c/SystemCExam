# 19 Билет
## Теория 

**Линейный односвязный список. Особенности создания и примеры использования.**

**Односвязный список** - это структура данных, в которой элементы одного типа связаны между собой указателями. Каждый элемент (узел) указывает на следующий, а последний — на nullptr. Хранятся элементы списка, как правило, в динамической памяти. 

Суть: Каждый элемент хранит данные + указатель на следующий.

Пример

![Photo](assets/Pasted%20image%2020251226071539.png)

## Особенности односвязного списка:

1. Связанность узлов: Узлы связаны друг с другом через указатели. Каждый узел содержит данные и указатель на следующий узел.
2. Порядок следования: Порядок следования элементов в списке задаётся порядком связей между узлами.
3. Динамическое размещение: Новые узлы создаются динамически в процессе работы программы, что позволяет гибко управлять памятью.
4. Лёгкость добавления узла: Новый узел легко добавляется в начало или конец списка путём изменения указателей соседних узлов.
5. Трудность доступа по индексу: Нет индексации, как в массивах. Для доступа к нужному элементу требуется пройтись по списку, начиная с первого узла.

Преимущества:
1. Гибкость: лёгкость добавления и удаления элементов.
2. Эффективность использования памяти: расходуется ровно столько памяти, сколько нужно для хранения данных.

Недостатки:
1. Отсутствие прямой индексации: для доступа к N-му элементу нужно пройти по всем предыдущим.
2. Медленный поиск: каждый поиск требует прохода по списку.

## Практика
Разработка программы для вычисления факториала в отдельном потоке. В программе должна быть предусмотрена валидация данных (отдельно для Windows и Linux)

Шаг 1. Для Windows создадим следующий файл main.c

``` C
#define _CRT_SECURE_NO_WARNINGS
#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>

long long getFact(int n) {
	long long result = 1; 
	for (int i = 1; i <= n; i++) {
		result *= i;
		if (result < 0) return -2; 
	}
	return result;
}

DWORD factCalc(LPVOID lpThreadParameter) {
	long long f = getFact(lpThreadParameter);
	if (f == -2) {
		printf("%s\n", "overflow");
	}
	else {
		printf("%d\n", f);
	}
}

int main() {
	system("chcp 1251");
	int n;
	scanf_s("%d", &n);
	if (n < 0) {
		printf("n must be > 0");
		return 0;
	}

	HANDLE threadF;
	threadF = CreateThread(0, 0, factCalc, n, 0, 0);
	WaitForSingleObject(threadF, INFINITE);
}

```

Шаг 2. Для Linux создадим следующий файл main.c

``` C
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

long long getF(int n) {
    int result = 1;
    for (size_t i = 1; i <= n; i++)
    {
        result *= i;
        if(result < 0) return -2;
    }
    return result;
}

void* CalcF(void* arg) {
    long long f = getF(arg);
    if(f == -2) {
        printf("Переполнение\n");
    }
    else {
        printf("факториал: %d\n", f);
    }
}

int main()
{
    pthread_t thread;

    printf("Введите n: ");
    int n;
    scanf("%d", &n);
    if (n < 0)
    {
        printf("n должно быть целым положительным числом\n");
        return 0;
    }

    pthread_create(&thread, 0, CalcF, n);
    pthread_join(&thread, 0);
    pthread_detach(&thread);
    return 1;
}
```